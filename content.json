{"meta":{"title":"MeetIn","subtitle":"Blog","description":null,"author":"MeetIn","url":"http://meetinco.github.io"},"pages":[{"title":"","date":"2016-06-04T10:31:20.000Z","updated":"2016-06-04T10:31:20.000Z","comments":false,"path":"tags/index.html","permalink":"http://meetinco.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微信公众号开发以及微信开发环境注意事项","slug":"2016-09-13-wei-xin-gong-zhong-hao-kai-fa-yi-ji-wei-xin-kai-fa-huan-jing-zhu-yi-shi-xiang","date":"2016-09-13T09:46:44.000Z","updated":"2016-09-13T12:42:04.000Z","comments":true,"path":"2016/09/13/2016-09-13-wei-xin-gong-zhong-hao-kai-fa-yi-ji-wei-xin-kai-fa-huan-jing-zhu-yi-shi-xiang/","link":"","permalink":"http://meetinco.github.io/2016/09/13/2016-09-13-wei-xin-gong-zhong-hao-kai-fa-yi-ji-wei-xin-kai-fa-huan-jing-zhu-yi-shi-xiang/","excerpt":"微信公众号开发其实不难但是开发的过程并不顺利，主要还是因为微信对访问的端口有限制（http支持80端口，https支持443端口）开发的时候没有想清楚，导致了很多不必要的失误","text":"微信公众号开发其实不难但是开发的过程并不顺利，主要还是因为微信对访问的端口有限制（http支持80端口，https支持443端口）开发的时候没有想清楚，导致了很多不必要的失误 接口配置配置的url供微信主动调用 GET 请求微信会验证当前的url是否可用, 验证方法就是向填写的url发送GET请求若确认此次GET请求来自微信服务器，原样返回echostr参数内容如何确认这是一次有效的验证请求呢？官方示例代码是PHP，在此贴出JavaScript代码以供参考 123456789//返回true，表示验证通过function x_verifyToken(timestamp, nonce, signature) &#123; var token = &apos;meetinisgood&apos;; var array = [token, timestamp, nonce]; var key = array.sort ().join (&apos;&apos;); var sha1 = crypto.createHash(&apos;sha1&apos;).update (key).digest (&apos;hex&apos;); // sha1 处理结束 return sha1 == signature&#125; POST 请求用户的操作均通过POST请求到达我们自己的服务器这里需要关心的是用户到底进行了什么操作？大部分通知都带有以上参数，请阅读相关章节了解上述参数可能的取值接收普通消息接收事件推送 access_token 机制为了保密appsecrect，第三方需要一个access_token获取和刷新的中控服务器我们会设置菜单按钮或向用户推送消息等等，这些都必须要access_tokenaccess_token 有一个特点就是，一旦重新获取access_token，原来的access_token就失效这引出了一个问题:&emsp;&emsp;正式环境和开发环境如何分别使用access_token? 正式环境和开发环境分别使用access_token微信提供了一个工具：这就意味着你拥有两个公众号，而且该测试公众号的接口权限全开正式环境使用正式的公众号，开发环境使用测试公众号但是这里还有一个问题：&emsp;&emsp;微信只访问80端口（http）和443端口（https），如果正式环境和测试环境使用了不同的端口，如何把属于开发环境的微信请求从80端口转到8080端口（开发环境端口）呢？ 把属于开发环境的微信请求从80端口转到8080端口这里就需要后台同学的支持了 1234Nate：同学，帮我搞一个端口转发呗Arden：转发规则是什么嘛Nate：80端口 /dev_wechat 下的请求转发到8080端口下的 /wechat，谢谢哈Arden：说馁些，不存在，没得似的 后台同学配置好端口转发之后，我们还需要做什么工作才能让开发环境收到来自微信的问候（token 验证）呢？ 正式公众号的服务器URL配置成：http://xxx.com/wechat 测试公众号的服务器URL配置成：http://xxx.com/dev_wechat 下面还会提到wechat和dev_wechat这样开发环境就可以收到来自微信的问候了~~~ 这样就够了吗？ NO~被坑过的我告诉你还有一项需要注意为了让html页面可以拿到用户的wx_openid，需要以下步骤： 用户访问HTML页面，这次访问的url: http://xxx.com/aaa/bb.html?name=xxx 没有发现参数 wx_openid 重定向到 http://xxx.com/wechat/request_openid携带参数 redirect_url=URLEncoding(&#39;http://xxx.com/aaa/bb.html?name=xxx&#39;) 组装一个回调url：redirect_url_1 = URLEncoding(&#39;http://xxx.com/wechat/code?redirect=URLEncoding(redirect_url)&#39;) 重定向到微信请求code（传入一个回调url：redirect_url_1） 微信将code发送到redirect_url_1 可以取到参数redirect_url向微信发送http请求，传入code异步返回用户的信息（openid）再次重定向到用户原来访问的url: redirect_url（追加了参数wx_openid） 看图理解说了一大堆获取wx_openid的步骤，就是为了指出其中一个容易搞混的地方注意图中 绿色的wechat正式环境使用 wechat， 开发环境使用dev_wechat（已经说过 wechat 和 dev_wechat 是什么啦）好了，就这样。","categories":[{"name":"前端","slug":"前端","permalink":"http://meetinco.github.io/categories/前端/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://meetinco.github.io/tags/微信公众号/"},{"name":"WeChat","slug":"WeChat","permalink":"http://meetinco.github.io/tags/WeChat/"},{"name":"ngnix","slug":"ngnix","permalink":"http://meetinco.github.io/tags/ngnix/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://meetinco.github.io/categories/前端/"}]},{"title":"Xcode auto release","slug":"Xcode-auto-release","date":"2016-06-04T10:25:05.000Z","updated":"2016-06-04T11:41:23.000Z","comments":true,"path":"2016/06/04/Xcode-auto-release/","link":"","permalink":"http://meetinco.github.io/2016/06/04/Xcode-auto-release/","excerpt":"曾使用过Xcode上传release包，平均耗时 1h，全程人工参与曾使用过Application Loader上传release包，平均耗时 20min，全程人工参与现在使用automator制作的自动传包工具AutoLoader，平均耗时 10min，人工参与2s","text":"曾使用过Xcode上传release包，平均耗时 1h，全程人工参与曾使用过Application Loader上传release包，平均耗时 20min，全程人工参与现在使用automator制作的自动传包工具AutoLoader，平均耗时 10min，人工参与2s 自动打包网上已经有许多开发者共享的打包脚本，只要输入一个命令就可以自动打包、发布、邮件通知。但是最近发现，一个简单的方法，可以让我们变得更懒一些。 预备知识这里不会专门讲解以下知识（因为你不需要这些知识也可以使用本文提供的工具），请自行了解 使用 automator Automator for Mac OS X: Tutorial and Examples 使用 shell script Shell脚本编程30分钟入门 使用 applescript Introduction to AppleScript Language Guide xcodebuild xcodebuild 手册 Application Loader altool altool 手册 使用xcodebuild打包xcodebuild打包、导出ipa都是使用的 xcodebuild可能你的工程需要指定 target，或者需要其他参数才能打出正确的包，了解一下xcodebuild还是很有必要的代码中用到的exportOptionsPlist是一个plis配置文件，稍后可以下载到 123456789#xcodebuild 简单示例#build cleanxcodebuild clean -configuration &quot;$configuration&quot; -alltargets#archivexcodebuild archive -workspace &quot;$workspaceName&quot; -scheme &quot;$scheme&quot; -configuration &quot;$configuration&quot; -archivePath $&#123;archivePath&#125;/$&#123;archiveName&#125;.xcarchive CODE_SIGN_IDENTITY=&quot;$codeSignIdentity&quot; PROVISIONING_PROFILE=&quot;$appStoreProvisioningProfile&quot;#导出到ipaxcodebuild -exportArchive -archivePath $&#123;archivePath&#125;/$&#123;archiveName&#125;.xcarchive -exportOptionsPlist &quot;$exportOptionsPlist&quot; -exportPath $&#123;archivePath&#125;/$&#123;archiveName&#125; 使用altool提交ipaApplication Loader altoolaltool 位于 Application Loader，三个参数 ipapath、appleid、password在这之前我都是使用的Application Loader上传包到 iTunesConnect 123456#altool 简单示例#validate&quot;$altoolPath&quot; --validate-app -f &quot;$ipaPath&quot; -u &quot;$appleid&quot; -p &quot;$applepassword&quot; -t ios --output-format xml#upload&quot;$altoolPath&quot; --upload-app -f &quot;$ipaPath&quot; -u &quot;$appleid&quot; -p &quot;$applepassword&quot; -t ios --output-format xml 使用 AutomatorAutomator创建的workflow可以和其他应用程序无缝衔接，在【服务】选项里面可以找到自己为某个目标定制的workflow。使用Automator为xcode定制一个【服务】很简单，所以并没有考虑为xcode开发一个插件。 打开Automator 新建一个service 修改服务需要的输入、选取需要服务的应用 加入流程一Automator应用界面左侧，打开资料库面板，点击【变量】，在搜索框中输入“path”，选择目标路径变量，拖拽到中间区域拖拽到中间区域 选取项目工程根路径在 Automator 应用界面的下方，双击刚才【Destination Path】，在弹出面板中选择工程路径，选择后点击【完成】 加入流程二automator应用界面左侧，打开资料库面板，点击【操作】，在搜索框中输入“applescript”，选择运行AppleScript，拖拽到中间区域步骤1的下方拖拽到中间区域 编辑 Applescript在 代码框中输入以下内容 1 on run &#123;input, parameters&#125; tell application &quot;Terminal&quot; activate do script &quot;cd &quot; &amp; input &amp; &quot; &amp;&amp; . BuildScript/xcode-archive-release.sh&quot; end tell return input end run 脚本文件 xcode-archive-release.sh 我放到了工程目录的 BuildScript 文件夹里面这段 Applescript 脚本做的事就是 打开 Terminal，cd 到工程目录，运行BuildScript文件夹里面的脚本文件 最终看起来是这个样子的 最后，保存文件，输入文件名字就可以了。打开xcode，看看是否有了新的 service 选项 资源下载 上传到 iTunesconnect shell 脚本 Automator workflow文件 下载的脚本文件解压后，放到项目里，与 xxx.xcworkspace（xxx.xcodeproj） 同一级 修改 xcode-archive-release.sh 里面的配置（见配置修改） 修改 release_exportOptions.plist 里面的 teamID 下载下来的 workflow 文件不用解压，用Automator打开，修改工程目录（参考使用 Automator） 配置修改打开 Terminal ,cd 到工程目录下，运行命令xcodebuild -list 12345678910111213$:xcodebuild -listTargets: XXXXXX XXXXXXTests Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used. Schemes: XXXXXX archiveName打包 archive 文件的名字（不用后缀） workspaceName工程文件的名字（需要后缀） scheme运行命令xcodebuild -list得到的Schemes，可能是一个列表，选一个你需要的 codeSignIdentity形如：iPhone Distribution: xxxx Inc. (xxxxxxx)进入Build Settings, 编辑Code Signing identity成打release包需要的，再点击一下刚才选中的选项，弹出框中点击Other就可以获得形如iPhone Distribution: xxxx Inc. (xxxxxxx)的数据 appStoreProvisioningProfile形如：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx获取方法与上面类似，最终获得形如xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx的数据 configuration值为：Release运行命令xcodebuild -list得到的Build Configurations，有两个选项，打release包，所以值为Release exportOptionsPlist存放release_exportOptions.plist文件的相对路径如果下载到的BuildScript文件夹存放到项目根目录，其值为BuildScript/release_exportOptions.plist ipaPath导出ipa文件的路径altool工具回到该路径获取需要上传的ipa文件，其值应为${PWD}/build/${archiveName}/${scheme}.ipa appleid开发者账号（邮箱） applepassword开发者账号的密码 最后本文讲述了Automator工具创建自动化流程，这仅仅是Automator的一部分。善用Automator，工作会更轻松。","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://meetinco.github.io/tags/Xcode/"},{"name":"automator","slug":"automator","permalink":"http://meetinco.github.io/tags/automator/"},{"name":"appscript","slug":"appscript","permalink":"http://meetinco.github.io/tags/appscript/"},{"name":"shell script","slug":"shell-script","permalink":"http://meetinco.github.io/tags/shell-script/"}],"keywords":[]}]}